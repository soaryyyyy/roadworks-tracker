package itu.cloud.roadworks.service;

import itu.cloud.roadworks.dto.SignalementPhotoDto;
import itu.cloud.roadworks.dto.SignalementProblemDto;
import itu.cloud.roadworks.model.Signalement;
import itu.cloud.roadworks.model.SignalementPhoto;
import itu.cloud.roadworks.model.SignalementStatus;
import itu.cloud.roadworks.model.SignalementWork;
import itu.cloud.roadworks.model.TypeProblem;
import itu.cloud.roadworks.model.Account;
import itu.cloud.roadworks.model.Company;
import itu.cloud.roadworks.repository.SignalementRepository;
import itu.cloud.roadworks.repository.SignalementPhotoRepository;
import itu.cloud.roadworks.repository.SignalementStatusRepository;
import itu.cloud.roadworks.repository.StatusSignalementRepository;
import itu.cloud.roadworks.repository.TypeProblemRepository;
import itu.cloud.roadworks.repository.AccountRepository;
import itu.cloud.roadworks.repository.SignalementWorkRepository;
import itu.cloud.roadworks.repository.CompanyRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import com.google.cloud.firestore.Firestore;
import com.google.cloud.firestore.QuerySnapshot;
import com.google.api.core.ApiFuture;

import java.time.Instant;
import java.time.LocalDate;
import java.math.BigDecimal;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class SignalementService {
    private final SignalementRepository repository;
    private final SignalementPhotoRepository photoRepository;
    private final SignalementStatusRepository statusRepository;
    private final StatusSignalementRepository statusSignalementRepository;
    private final TypeProblemRepository typeProblemRepository;
    private final AccountRepository accountRepository;
    private final SignalementWorkRepository workRepository;
    private final CompanyRepository companyRepository;
    private final FirebaseService firebaseService;
    private final NotificationService notificationService;

    public List<SignalementProblemDto> findAllProblems() {
        return repository.findAll()
                .stream()
                .map(this::toProblemDto)
                .collect(Collectors.toList());
    }

    private SignalementProblemDto toProblemDto(Signalement signalement) {
        SignalementStatus latestStatus = signalement.getStatuses().stream().findFirst().orElse(null);
        SignalementWork latestWork = signalement.getWorks().stream().findFirst().orElse(null);

        SignalementProblemDto.SignalementProblemDetail detail = SignalementProblemDto.SignalementProblemDetail.builder()
                .etat(Optional.ofNullable(latestStatus).map(s -> s.getStatusSignalement().getLibelle()).orElse(null))
                .dateProblem(signalement.getCreatedAt())
                .surfaceM2(signalement.getSurface())
                .budget(latestWork != null ? latestWork.getPrice() : null)
                .entrepriseAssign(Optional.ofNullable(latestWork)
                        .map(work -> SignalementProblemDto.CompanyDto.builder()
                                .id(work.getCompany().getId())
                                .name(work.getCompany().getName())
                                .build())
                        .orElse(null))
                .description(signalement.getDescriptions())
                .build();

        return SignalementProblemDto.builder()
                .id(signalement.getId())
                .typeProblem(signalement.getTypeProblem().getLibelle())
                .illustrationProblem(signalement.getTypeProblem().getIcone())
                .location(signalement.getLocation())
                .detail(detail)
                .build();
    }

    public void updateStatus(Long signalementId, String statusName, String realEndDate) throws Exception {
        Signalement signalement = repository.findById(signalementId)
                .orElseThrow(() -> new Exception("Signalement non trouvé"));

        var statusSignalement = statusSignalementRepository.findByLibelle(statusName)
                .orElseThrow(() -> new Exception("Statut invalide: " + statusName));

        SignalementStatus newStatus = SignalementStatus.builder()
                .signalement(signalement)
                .statusSignalement(statusSignalement)
                .updatedAt(Instant.now())
                .build();

        statusRepository.save(newStatus);

        // Si le statut est "terminé" et une date est fournie, mettre à jour la date réelle de fin du travail
        if ("terminé".equals(statusName) && realEndDate != null && !realEndDate.trim().isEmpty()) {
            // Trouver le travail associé à ce signalement
            List<SignalementWork> works = workRepository.findBySignalementId(signalementId);
            if (!works.isEmpty()) {
                // Mettre à jour le dernier travail avec la date réelle
                SignalementWork work = works.get(works.size() - 1);
                work.setRealEndDate(java.time.LocalDate.parse(realEndDate));
                workRepository.save(work);
                System.out.println("Date réelle de fin mise à jour: " + realEndDate);
            }
        }

        // Notification WebSocket
        notificationService.notifyStatusUpdated(signalement, statusName);

        // Synchroniser vers Firebase pour notifier l'utilisateur mobile
        try {
            syncToFirebase(signalementId);
            System.out.println("Signalement synchronisé vers Firebase après mise à jour du statut");
        } catch (Exception e) {
            System.err.println("Erreur lors de la synchronisation vers Firebase: " + e.getMessage());
            // On ne propage pas l'erreur pour ne pas bloquer la mise à jour du statut
        }
    }

    // Méthode surchargée pour la rétro-compatibilité
    public void updateStatus(Long signalementId, String statusName) throws Exception {
        updateStatus(signalementId, statusName, null);
    }

    public int syncFromFirebase() throws Exception {
        System.out.println("=== DEBUT SYNCFROMFIREBASE ===");
        
        Firestore db = firebaseService.getFirestore();
        System.out.println("Firestore instance: " + (db != null ? "OK" : "NULL"));
        
        if (db == null) {
            System.out.println("Firebase n'est pas initialisé - retour 0 synchronisé");
            return 0;
        }

        try {
            System.out.println("Récupération des documents de la collection 'roadworks_reports'");
            ApiFuture<QuerySnapshot> query = db.collection("roadworks_reports").get();
            
            // Ajouter un timeout de 30 secondes
            System.out.println("Attendre la réponse de Firestore...");
            QuerySnapshot querySnapshot = query.get(30, java.util.concurrent.TimeUnit.SECONDS);
            System.out.println("Nombre de documents trouvés: " + querySnapshot.getDocuments().size());

            int count = 0;
            Account defaultAccount = accountRepository.findByUsername("admin").orElse(null);
            TypeProblem defaultType = typeProblemRepository.findByLibelle("other")
                    .orElseGet(() -> typeProblemRepository.findAll().stream().findFirst().orElse(null));

            if (defaultAccount == null || defaultType == null) {
                System.out.println("Compte admin ou type de problème non trouvé");
                return 0;
            }

            for (var document : querySnapshot.getDocuments()) {
                try {
                    String firebaseId = document.getId();
                    System.out.println("\n--- Traitement du document: " + firebaseId + " ---");

                    // Vérifier si ce signalement a déjà été synchronisé
                    if (repository.findByFirebaseId(firebaseId).isPresent()) {
                        System.out.println("✓ Signalement Firebase déjà synchronisé: " + firebaseId);
                        continue;
                    }

                    String description = document.getString("description");
                    // Support des deux formats de coordonnées: lat/lng ou latitude/longitude
                    Double lat = document.getDouble("lat");
                    if (lat == null) {
                        lat = document.getDouble("latitude");
                    }
                    Double lng = document.getDouble("lng");
                    if (lng == null) {
                        lng = document.getDouble("longitude");
                    }
                    String status = document.getString("status"); // Type de problème: pothole, accident, etc.
                    String reportStatus = document.getString("reportStatus"); // État du signalement: new, in_progress, completed

                    System.out.println("Valeurs trouvées:");
                    System.out.println("  description: " + description);
                    System.out.println("  lat: " + lat);
                    System.out.println("  lng: " + lng);
                    System.out.println("  status (type): " + status);
                    System.out.println("  reportStatus (état): " + reportStatus);
                    System.out.println("Tous les champs du document: " + document.getData());

                    if (lat != null && lng != null) {
                        System.out.println("✓ Champs requis présents, création du signalement...");

                        // Mapper le type de problème Firebase vers la base de données
                        TypeProblem typeProblem = defaultType;
                        if (status != null && !status.isEmpty()) {
                            typeProblem = typeProblemRepository.findByLibelle(status).orElse(defaultType);
                            System.out.println("  Type de problème mappé: " + typeProblem.getLibelle());
                        }

                        Signalement signalement = Signalement.builder()
                                .account(defaultAccount)
                                .typeProblem(typeProblem)
                                .descriptions(description != null ? description : "")
                                .location(lat + "," + lng)
                                .createdAt(Instant.now())
                                .firebaseId(firebaseId)
                                .build();

                        Signalement saved = repository.save(signalement);
                        System.out.println("✓ Signalement sauvegardé avec ID: " + saved.getId());

                        // Vérifier s'il y a des informations de travail dans le document Firebase
                        Map<String, Object> workInfo = (Map<String, Object>) document.get("work");
                        boolean hasWork = workInfo != null;
                        System.out.println("✓ Document a du travail: " + hasWork);

                        // Mapper le statut Firestore vers les statuts de la base
                        // Si reportStatus existe, l'utiliser, sinon "nouveau"
                        String statusToUse = "nouveau";

                        if (reportStatus != null && !reportStatus.isEmpty()) {
                            String firebaseReportStatus = reportStatus.toLowerCase().trim();
                            System.out.println("  Mapping du reportStatus: '" + reportStatus + "' -> '" + firebaseReportStatus + "'");

                            // Mapping reportStatus Firebase → Base de données
                            if (firebaseReportStatus.equals("in_progress") || firebaseReportStatus.equals("en_cours")) {
                                statusToUse = "en_cours";
                                System.out.println("    Résultat: 'en_cours'");
                            } else if (firebaseReportStatus.equals("completed") || firebaseReportStatus.equals("terminé") || firebaseReportStatus.equals("resolved")) {
                                statusToUse = "terminé";
                                System.out.println("    Résultat: 'terminé'");
                            } else if (firebaseReportStatus.equals("cancelled") || firebaseReportStatus.equals("annulé") || firebaseReportStatus.equals("rejected")) {
                                statusToUse = "annulé";
                                System.out.println("    Résultat: 'annulé'");
                            } else {
                                // new ou autre valeur → nouveau
                                statusToUse = "nouveau";
                                System.out.println("    Résultat: 'nouveau' (default)");
                            }
                        } else {
                            System.out.println("  reportStatus absent -> Statut par défaut: 'nouveau'");
                        }

                        System.out.println("Statut final à utiliser: " + statusToUse);

                        // Convertir en final pour la lambda
                        final String finalStatusToUse = statusToUse;
                        
                        var statusSignalement = statusSignalementRepository
                                .findByLibelle(finalStatusToUse)
                                .orElseGet(() -> {
                                    System.out.println("⚠️  Statut '" + finalStatusToUse + "' non trouvé, utilisation du statut 'nouveau'");
                                    return statusSignalementRepository.findByLibelle("nouveau").orElse(null);
                                });

                        if (statusSignalement != null) {
                            System.out.println("✓ StatusSignalement trouvé: " + statusSignalement.getLibelle());

                            SignalementStatus signalStatus = SignalementStatus.builder()
                                    .signalement(saved)
                                    .statusSignalement(statusSignalement)
                                    .updatedAt(Instant.now())
                                    .build();
                            statusRepository.save(signalStatus);
                            System.out.println("✓ Status créé et sauvegardé");

                            // Vérifier s'il y a des informations de travail dans le document Firebase (déjà extrait plus haut)
                            if (workInfo != null) {
                                System.out.println("✓ Informations de travail trouvées dans Firebase");
                                try {
                                    // Extraire les données du travail
                                    String companyName = (String) workInfo.get("company");
                                    Number surface = (Number) workInfo.get("surface");
                                    Number price = (Number) workInfo.get("price");
                                    String startDateStr = (String) workInfo.get("startDate");
                                    String endDateStr = (String) workInfo.get("endDateEstimation");

                                    System.out.println("  Données extraites:");
                                    System.out.println("    Company: " + companyName);
                                    System.out.println("    Surface: " + surface);
                                    System.out.println("    Price: " + price);
                                    System.out.println("    StartDate: " + startDateStr);
                                    System.out.println("    EndDate: " + endDateStr);

                                    // Si on a au moins une entreprise et un prix, créer le SignalementWork
                                    if (companyName != null && !companyName.isEmpty()) {
                                        // Chercher ou créer l'entreprise
                                        Company company = companyRepository.findByName(companyName)
                                                .orElseGet(() -> {
                                                    System.out.println("  Création d'une nouvelle entreprise: " + companyName);
                                                    Company newCompany = Company.builder()
                                                            .name(companyName)
                                                            .siret("UNKNOWN") // Valeur par défaut
                                                            .address("") // Vide
                                                            .build();
                                                    return companyRepository.save(newCompany);
                                                });

                                        System.out.println("  Entreprise trouvée/créée: " + company.getName());

                                        // Créer le SignalementWork
                                        LocalDate startDate = null;
                                        LocalDate endDate = null;

                                        if (startDateStr != null && !startDateStr.isEmpty()) {
                                            try {
                                                startDate = LocalDate.parse(startDateStr);
                                                System.out.println("  StartDate parsée: " + startDate);
                                            } catch (Exception e) {
                                                System.out.println("  ⚠️ Impossible de parser startDate: " + startDateStr);
                                            }
                                        }

                                        if (endDateStr != null && !endDateStr.isEmpty()) {
                                            try {
                                                endDate = LocalDate.parse(endDateStr);
                                                System.out.println("  EndDate parsée: " + endDate);
                                            } catch (Exception e) {
                                                System.out.println("  ⚠️ Impossible de parser endDate: " + endDateStr);
                                            }
                                        }

                                        BigDecimal priceValue = null;
                                        if (price != null) {
                                            priceValue = BigDecimal.valueOf(price.doubleValue());
                                            System.out.println("  Price convertie: " + priceValue);
                                        }

                                        // Mettre à jour la surface du signalement
                                        if (surface != null) {
                                            saved.setSurface(BigDecimal.valueOf(surface.doubleValue()));
                                            repository.save(saved);
                                            System.out.println("  Surface mise à jour: " + surface);
                                        }

                                        // Créer le SignalementWork
                                        SignalementWork work = SignalementWork.builder()
                                                .signalement(saved)
                                                .company(company)
                                                .startDate(startDate)
                                                .endDateEstimation(endDate)
                                                .price(priceValue)
                                                .build();

                                        workRepository.save(work);
                                        System.out.println("✓ SignalementWork créé et sauvegardé pour le signalement: " + saved.getId());
                                    }
                                } catch (Exception e) {
                                    System.err.println("  ❌ Erreur lors de la création du SignalementWork: " + e.getMessage());
                                    e.printStackTrace();
                                }
                            } else {
                                System.out.println("✓ Pas de travail associé dans Firebase");
                            }

                            count++;
                            System.out.println("✓ Signalement importé avec succès! (Total: " + count + ")");

                            // Envoyer notification WebSocket pour nouveau signalement
                            notificationService.notifyNewSignalement(saved);
                        } else {
                            System.out.println("❌ ERREUR: StatusSignalement null pour '" + finalStatusToUse + "'");
                        }
                    } else {
                        System.out.println("❌ Document incomplet:");
                        System.out.println("   lat: " + (lat == null ? "NULL" : "OK"));
                        System.out.println("   lng: " + (lng == null ? "NULL" : "OK"));
                    }
                } catch (Exception e) {
                    System.err.println("❌ ERREUR lors de la synchronisation du document: " + e.getMessage());
                    e.printStackTrace();
                }
            }

            System.out.println("Synchronisation terminée: " + count + " signalements importés");

            // Notification de fin de synchronisation
            if (count > 0) {
                notificationService.notifySyncCompleted(count);
            }

            return count;
        } catch (java.util.concurrent.TimeoutException e) {
            System.err.println("TIMEOUT: Firestore n'a pas répondu après 30 secondes");
            System.out.println("Retour 0 synchronisé (timeout Firestore)");
            return 0;
        } catch (com.google.api.gax.rpc.UnavailableException e) {
            System.err.println("Firestore indisponible - Credentials invalides ou pas de connexion");
            System.out.println("Retour 0 synchronisé (Firestore indisponible)");
            return 0;
        } catch (Exception e) {
            System.err.println("Erreur lors de la synchronisation Firebase: " + e.getMessage());
            e.printStackTrace();
            System.out.println("Retour 0 synchronisé (erreur)");
            return 0;
        }
    }

    public void addWork(Long signalementId, Map<String, Object> workData) throws Exception {
        try {
            Signalement signalement = repository.findById(signalementId)
                    .orElseThrow(() -> new Exception("Signalement non trouvé"));

            // Mettre à jour la surface
            if (workData.containsKey("surface") && workData.get("surface") != null) {
                Double surface = ((Number) workData.get("surface")).doubleValue();
                signalement.setSurface(BigDecimal.valueOf(surface));
            }

            // Sauvegarder le signalement d'abord
            repository.save(signalement);

            // Récupérer l'entreprise par ID
            Long companyId = null;
            if (workData.containsKey("companyId")) {
                Object companyIdObj = workData.get("companyId");
                if (companyIdObj instanceof Number) {
                    companyId = ((Number) companyIdObj).longValue();
                } else if (companyIdObj instanceof String) {
                    companyId = Long.parseLong((String) companyIdObj);
                }
            }

            if (companyId == null) {
                throw new Exception("L'ID de l'entreprise est obligatoire");
            }

            Company company = companyRepository.findById(companyId)
                    .orElseThrow(() -> new Exception("Entreprise non trouvée"));

            // Créer le SignalementWork
            LocalDate startDate = null;
            LocalDate endDate = null;

            if (workData.containsKey("startDate") && workData.get("startDate") != null) {
                String startDateStr = (String) workData.get("startDate");
                if (!startDateStr.isEmpty()) {
                    startDate = LocalDate.parse(startDateStr);
                }
            }

            if (workData.containsKey("endDate") && workData.get("endDate") != null) {
                String endDateStr = (String) workData.get("endDate");
                if (!endDateStr.isEmpty()) {
                    endDate = LocalDate.parse(endDateStr);
                }
            }

            SignalementWork work = SignalementWork.builder()
                    .signalement(signalement)
                    .company(company)
                    .startDate(startDate)
                    .endDateEstimation(endDate)
                    .price(BigDecimal.valueOf(((Number) workData.get("price")).doubleValue()))
                    .build();

            workRepository.save(work);

            // Mettre à jour le statut à "en_cours"
            String status = (String) workData.getOrDefault("status", "en_cours");
            var statusSignalement = statusSignalementRepository.findByLibelle(status)
                    .orElseThrow(() -> new Exception("Statut invalide: " + status));

            SignalementStatus signalStatus = SignalementStatus.builder()
                    .signalement(signalement)
                    .statusSignalement(statusSignalement)
                    .updatedAt(Instant.now())
                    .build();

            statusRepository.save(signalStatus);

            // Notification WebSocket
            notificationService.notifyWorkAdded(signalement, company.getName());
        } catch (Exception e) {
            System.err.println("Erreur dans addWork: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    public void syncToFirebase(Long signalementId) throws Exception {
        try {
            Signalement signalement = repository.findById(signalementId)
                    .orElseThrow(() -> new Exception("Signalement non trouvé"));

            Firestore db = firebaseService.getFirestore();
            if (db == null) {
                throw new Exception("Firebase n'est pas initialisé");
            }

            // Récupérer le dernier statut (nouveau, en_cours, terminé, annulé)
            SignalementStatus latestStatus = signalement.getStatuses().stream().findFirst().orElse(null);
            String reportStatus = latestStatus != null ? latestStatus.getStatusSignalement().getLibelle() : "nouveau";

            // Mapper le statut backend vers le format mobile
            String mobileReportStatus = "new";
            if ("en_cours".equals(reportStatus)) {
                mobileReportStatus = "in_progress";
            } else if ("terminé".equals(reportStatus) || "resolu".equals(reportStatus)) {
                mobileReportStatus = "completed";
            }

            // Récupérer le dernier work s'il existe
            SignalementWork latestWork = signalement.getWorks().stream().findFirst().orElse(null);

            // Extraire lat et lng depuis location
            String[] coords = signalement.getLocation().split(",");
            double lat = Double.parseDouble(coords[0].trim());
            double lng = Double.parseDouble(coords[1].trim());

            // Préparer les données à synchroniser
            Map<String, Object> data = new java.util.HashMap<>();
            data.put("description", signalement.getDescriptions());
            data.put("lat", lat);
            data.put("lng", lng);
            data.put("status", signalement.getTypeProblem().getLibelle()); // Type de problème: pothole, accident, etc.
            data.put("reportStatus", mobileReportStatus); // Statut: new, in_progress, completed
            data.put("lastUpdated", Instant.now().toString());

            // Préserver le userId existant si le document existe déjà dans Firebase
            String firebaseId = signalement.getFirebaseId();
            if (firebaseId != null && !firebaseId.isEmpty()) {
                try {
                    var existingDoc = db.collection("roadworks_reports").document(firebaseId).get().get();
                    if (existingDoc.exists() && existingDoc.getString("userId") != null) {
                        data.put("userId", existingDoc.getString("userId"));
                    }
                } catch (Exception e) {
                    System.err.println("Impossible de récupérer le userId existant: " + e.getMessage());
                }
            }

            // Ajouter les informations de travail si elles existent
            if (latestWork != null) {
                Map<String, Object> workData = new java.util.HashMap<>();
                workData.put("surface", signalement.getSurface() != null ? signalement.getSurface().doubleValue() : null);
                workData.put("company", latestWork.getCompany().getName());
                workData.put("companyId", latestWork.getCompany().getId());
                workData.put("startDate", latestWork.getStartDate() != null ? latestWork.getStartDate().toString() : null);
                workData.put("endDateEstimation", latestWork.getEndDateEstimation() != null ? latestWork.getEndDateEstimation().toString() : null);
                workData.put("realEndDate", latestWork.getRealEndDate() != null ? latestWork.getRealEndDate().toString() : null);
                workData.put("price", latestWork.getPrice() != null ? latestWork.getPrice().doubleValue() : null);
                data.put("work", workData);
            }

            // Si le signalement a un firebaseId, mettre à jour le document existant
            // Sinon, créer un nouveau document
            if (firebaseId != null && !firebaseId.isEmpty()) {
                db.collection("roadworks_reports").document(firebaseId).set(data).get();
            } else {
                // Créer un nouveau document et sauvegarder son ID
                var docRef = db.collection("roadworks_reports").add(data).get();
                signalement.setFirebaseId(docRef.getId());
                repository.save(signalement);
            }

        } catch (Exception e) {
            System.err.println("Erreur dans syncToFirebase: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Récupère les signalements Firebase qui ne sont pas encore synchronisés dans la base de données locale.
     * Utile pour le manager afin de voir tous les signalements, même ceux non encore importés.
     */
    public List<Map<String, Object>> getUnsyncedFirebaseSignalements() throws Exception {
        System.out.println("=== DEBUT getUnsyncedFirebaseSignalements ===");
        
        Firestore db = firebaseService.getFirestore();
        if (db == null) {
            System.out.println("Firebase n'est pas initialisé - retour liste vide");
            return List.of();
        }

        try {
            ApiFuture<QuerySnapshot> query = db.collection("roadworks_reports").get();
            QuerySnapshot querySnapshot = query.get(30, java.util.concurrent.TimeUnit.SECONDS);
            System.out.println("Nombre de documents Firebase trouvés: " + querySnapshot.getDocuments().size());

            List<Map<String, Object>> unsyncedSignalements = new java.util.ArrayList<>();

            for (var document : querySnapshot.getDocuments()) {
                String firebaseId = document.getId();
                
                // Vérifier si ce signalement a déjà été synchronisé
                if (repository.findByFirebaseId(firebaseId).isPresent()) {
                    // Déjà synchronisé, on l'ignore
                    continue;
                }

                // Ce signalement n'est pas synchronisé, on le récupère
                // DEBUG: Afficher tous les champs du document pour comprendre la structure
                System.out.println("=== Document Firebase " + firebaseId + " ===");
                System.out.println("Tous les champs: " + document.getData());

                String description = document.getString("description");
                // Support de plusieurs formats de coordonnées
                Double lat = document.getDouble("lat");
                if (lat == null) {
                    lat = document.getDouble("latitude");
                }
                // Essayer aussi avec "location" qui pourrait être un objet
                if (lat == null && document.get("location") != null) {
                    try {
                        Map<String, Object> location = (Map<String, Object>) document.get("location");
                        if (location != null) {
                            Object latObj = location.get("lat");
                            if (latObj == null) latObj = location.get("latitude");
                            if (latObj instanceof Number) {
                                lat = ((Number) latObj).doubleValue();
                            }
                        }
                    } catch (Exception e) {
                        System.out.println("  location n'est pas un objet Map");
                    }
                }

                Double lng = document.getDouble("lng");
                if (lng == null) {
                    lng = document.getDouble("longitude");
                }
                if (lng == null && document.get("location") != null) {
                    try {
                        Map<String, Object> location = (Map<String, Object>) document.get("location");
                        if (location != null) {
                            Object lngObj = location.get("lng");
                            if (lngObj == null) lngObj = location.get("longitude");
                            if (lngObj == null) lngObj = location.get("lon");
                            if (lngObj instanceof Number) {
                                lng = ((Number) lngObj).doubleValue();
                            }
                        }
                    } catch (Exception e) {
                        System.out.println("  location n'est pas un objet Map");
                    }
                }

                String status = document.getString("status"); // Type de problème
                String reportStatus = document.getString("reportStatus"); // État du signalement
                Object timestamp = document.get("timestamp");

                System.out.println("  Coordonnées extraites - lat: " + lat + ", lng: " + lng);

                if (lat != null && lng != null) {
                    Map<String, Object> signalementData = new java.util.HashMap<>();
                    signalementData.put("firebaseId", firebaseId);
                    signalementData.put("description", description != null ? description : "Aucune description");
                    signalementData.put("lat", lat);
                    signalementData.put("lng", lng);
                    signalementData.put("typeProblem", status != null ? status : "other");
                    signalementData.put("reportStatus", reportStatus != null ? reportStatus : "new");
                    signalementData.put("timestamp", timestamp);
                    signalementData.put("isSynced", false); // Marqueur pour le frontend
                    
                    unsyncedSignalements.add(signalementData);
                }
            }

            System.out.println("Nombre de signalements non synchronisés: " + unsyncedSignalements.size());
            return unsyncedSignalements;

        } catch (Exception e) {
            System.err.println("Erreur lors de la récupération des signalements Firebase non synchronisés: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Récupère toutes les photos d'un signalement par son ID.
     */
    public List<SignalementPhotoDto> getPhotosBySignalementId(Long signalementId) throws Exception {
        // Vérifier que le signalement existe
        repository.findById(signalementId)
                .orElseThrow(() -> new Exception("Signalement non trouvé avec l'ID: " + signalementId));

        List<SignalementPhoto> photos = photoRepository.findBySignalementIdOrderByPhotoOrderAsc(signalementId);

        return photos.stream()
                .map(photo -> SignalementPhotoDto.builder()
                        .id(photo.getId())
                        .signalementId(signalementId)
                        .photoData(photo.getPhotoData())
                        .photoOrder(photo.getPhotoOrder())
                        .createdAt(photo.getCreatedAt())
                        .build())
                .collect(Collectors.toList());
    }
}
